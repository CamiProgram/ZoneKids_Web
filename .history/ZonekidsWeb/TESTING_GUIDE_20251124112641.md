# ZoneKids Frontend Testing Guide

## Quick Start

### Install Dependencies
```bash
cd ZonekidsWeb
npm install --legacy-peer-deps
```

### Run Tests
```bash
# Run all tests once
npm run test -- --run

# Run tests in watch mode (auto-rerun on changes)
npm run test

# Run with interactive UI
npm run test:ui

# Generate coverage report
npm run test:coverage

# Run specific test file
npm run test -- src/pages/user/LoginPage.test.jsx
```

---

## Test Files Overview

### User-Facing Pages (4 tests)
1. **LoginPage.test.jsx** - Login form validation and authentication
2. **RegisterPage.test.jsx** - Registration form and validation
3. **HomePage.test.jsx** - Main page with product listings
4. **ProductDetailPage.test.jsx** - Product details with 30-second autoplay carousel

### Shopping Pages (1 test)
5. **CheckoutPage.test.jsx** - Cart management and checkout process

### Admin Pages (2 tests)
6. **AdminDashboard.test.jsx** - User management overview
7. **AdminProducts.test.jsx** - Product management interface

---

## Test Structure

All tests follow the Duoc UC standard pattern:

```javascript
describe('PageName', () => {
  beforeEach(() => {
    // Setup before each test
  });

  afterEach(() => {
    // Cleanup after each test
  });

  it('debe [Spanish description of expected behavior]', () => {
    // Arrange, Act, Assert pattern
  });
});
```

---

## Writing New Tests

### Basic Test Template
```javascript
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { MyComponent } from './MyComponent';

describe('MyComponent', () => {
  it('debe renderizar correctamente', () => {
    render(<MyComponent />);
    expect(screen.getByText('Expected Text')).toBeInTheDocument();
  });
});
```

### Testing User Interactions
```javascript
import userEvent from '@testing-library/user-event';

it('debe responder a clicks', async () => {
  const user = userEvent.setup();
  render(<MyComponent />);
  
  const button = screen.getByRole('button', { name: /click me/i });
  await user.click(button);
  
  expect(screen.getByText('Button clicked')).toBeInTheDocument();
});
```

### Testing Async Operations
```javascript
import { waitFor } from '@testing-library/react';

it('debe cargar datos', async () => {
  render(<MyComponent />);
  
  await waitFor(() => {
    expect(screen.getByText('Data loaded')).toBeInTheDocument();
  });
});
```

### Mocking Services
```javascript
import { vi } from 'vitest';

vi.mock('../../services/myService', () => ({
  myService: {
    getData: vi.fn(),
  },
}));

it('debe usar servicio mockeado', async () => {
  const service = vi.mocked(require('../../services/myService').myService);
  service.getData.mockResolvedValueOnce({ id: 1, name: 'Test' });
  
  // Test code here
});
```

---

## Best Practices

### ✅ DO
- Use semantic queries (getByRole, getByLabelText)
- Test user behavior, not implementation
- Keep tests focused on one behavior
- Use descriptive test names in Spanish
- Mock external services and APIs
- Use `waitFor` for async operations
- Clean up after each test with `afterEach`

### ❌ DON'T
- Use `querySelector` or `getElementById`
- Test internal state directly
- Create tests that depend on other tests
- Mock the entire module if only one function is needed
- Forget to use `async/await` for user interactions
- Leave mocks un-cleared between tests

---

## Common Patterns

### Testing Form Submission
```javascript
const user = userEvent.setup();
const emailInput = screen.getByLabelText(/email/i);
const submitButton = screen.getByRole('button', { name: /submit/i });

await user.type(emailInput, 'test@example.com');
await user.click(submitButton);

await waitFor(() => {
  expect(mockFunction).toHaveBeenCalled();
});
```

### Testing Conditional Rendering
```javascript
expect(screen.queryByText('Error message')).not.toBeInTheDocument();

// Then trigger error condition
await user.click(badButton);

expect(screen.getByText('Error message')).toBeInTheDocument();
```

### Testing Navigation
```javascript
const mockNavigate = vi.fn();
vi.mock('react-router-dom', () => ({
  ...actualModule,
  useNavigate: () => mockNavigate,
}));

// After action
expect(mockNavigate).toHaveBeenCalledWith('/expected-route');
```

---

## Configuration Files

### setupTests.ts
Global test setup with mocks for:
- localStorage
- window.matchMedia
- IntersectionObserver

### vitest.config.ts
- Uses jsdom for DOM simulation
- Enables globals (no need to import describe/it)
- References setupTests.ts for setup
- Configured for coverage reporting

### testUtils.jsx
Helper functions for rendering components with necessary contexts:
```javascript
renderWithContexts(<MyComponent />, {
  authValue: { user: null, token: null },
  cartValue: { cart: [], addToCart: () => {} }
});
```

---

## Troubleshooting

### "Cannot find module" errors
Usually means a service mock isn't set up. Add:
```javascript
vi.mock('../../services/myService', () => ({
  myService: { method: vi.fn() }
}));
```

### "useXContext must be used within Provider"
Use `renderWithContexts` from testUtils.jsx instead of plain `render`:
```javascript
import { renderWithContexts } from '../../utils/testUtils';
renderWithContexts(<MyComponent />);
```

### Async tests timing out
Use `waitFor` with longer timeout:
```javascript
await waitFor(() => {
  expect(element).toBeInTheDocument();
}, { timeout: 3000 });
```

### Elements not found after user interaction
Always use `await` with userEvent and `waitFor` for assertions:
```javascript
await user.click(button);
await waitFor(() => {
  expect(screen.getByText('Result')).toBeInTheDocument();
});
```

---

## Coverage Reports

Generate coverage:
```bash
npm run test:coverage
```

Reports are generated in `coverage/` directory with:
- `coverage/index.html` - Interactive coverage report
- `coverage/coverage-final.json` - Machine-readable coverage
- Terminal summary showing coverage percentages

---

## IDE Integration

### VS Code Vitest Extension
Install "Vitest" extension for:
- Run tests from UI
- Inline test results
- Coverage highlighting
- Debug tests

### Running Tests from IDE
- Click ▶️ next to test name
- Right-click test file → Run Tests
- Use command palette: "Vitest: Run"

---

## CI/CD Integration

### GitHub Actions Example
```yaml
- name: Run tests
  run: npm run test -- --run

- name: Generate coverage
  run: npm run test:coverage

- name: Upload coverage
  uses: codecov/codecov-action@v3
```

---

## Resources

- [Vitest Documentation](https://vitest.dev/)
- [Testing Library Documentation](https://testing-library.com/)
- [Jest Matchers (Vitest compatible)](https://vitest.dev/api/expect.html)
- [User Event Documentation](https://testing-library.com/docs/user-event/intro)

---

## Support

For issues or questions about tests:
1. Check this guide for troubleshooting
2. Review test files for similar patterns
3. Check Testing Library docs for query methods
4. Review test file comments for implementation details

---

**Project:** ZoneKids E-Commerce Frontend  
**Testing Framework:** Vitest + @testing-library/react  
**Last Updated:** November 24, 2025
